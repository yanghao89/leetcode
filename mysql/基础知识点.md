# mysql 基础知识

```
server层 客户端->连接器->分析器->优化器->执行器

mysql pagecache 是16k

crash-safe  : 应急安全的

```
```
这个两种日志有一下三点不同

redo.log 重做日志 是innodb 特有的; 物理日志,


binlog  归档日志 是mysql 的sever 层实现的,所有引擎都可以使用 
binlog是逻辑日志,记录的是这个语句的原始逻辑

redolog和binlog都可以用于表示事务的提交状态，
而两阶段提交就是让这两个状态保持逻辑上的一致。

redolog用于保证crash-safe能力,innodb_flush_log_at_trx_commit= 1

sync_binlog = 1 每次事务的binlog都持久化到磁盘

定期备份最后是一天一备。

unod.log 

```

```text
事务的隔离性与隔离级别

ACID 即为 原子性,一致性,隔离性,持久性

读未提交： read uncommitted  (RU)
读提交: Read Committed (RC)
可重复读: repeatable read (RR mysql 默认 隔离级别)
串行化: serializable


读未提交：一个事务还没提交时，它做的变更就能被别的事务看到。
读提交：一个事务提交之后，它做的变更才会被其他事务看到
可重复读：一个事务执行过程中看到的数据,总是跟这个事务在启动时看到的数据是一致的
当然在可重复读隔离级别下,未提交变更对其他事务也是不可见的。

串行化：写会加写锁，读会加读锁,当出现读写锁冲突的时候,后访问的事务必须等前一个事务执行完毕后
才可以执行

多事务同时执行的时候,可能会出现的问题:脏读,不可重复读,幻读


事务隔离实现:每条记录在更新的时候都会同时记录一条回滚操作。同一条记录在系统中可以存在
多个版本,就是数据库的多版本并发控制(mvcc)

回滚日志什么时候删除? 系统会判断当没有事务需要用到这些回滚日志的时候,回滚日志会被删除
什么时候不需要了？当系统里么有比这个回滚日志更早的read-view的时候。

隔离的实现主要有读写锁和MVCC（Multi-Version Concurrency Control）多版本并发处理方式。





mysql: RR 可重复读
Oracle ： RC 读提交


```


```text
索引常见的模型
哈希表,有序数组,搜索树

show variables like 'innodb_page_size': 16384(b)/ 1024 = 16k

为什么索引要用二叉树,而不是哈希表和有序数组，或者是搜索树

1：为什么不用哈希表
如果哈希冲突后就需要拉出一个链表,解决冲突,
在查找链表的中的数据就必须遍历，时间复杂度为O(N)
所以哈希索引区间查询的速度是很慢

2: 有序数组在等值查询和范围查询场景中的性能就都非常优秀,但是在往中间插入一个记录时
就必须得挪动后面所有的记录。
所以有序索引只适用静态存储引擎

3:

```